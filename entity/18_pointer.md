# アドレス

[変数のページ](06_variable.md)でも話したように変数はメモリに置かれる (メモリに置かれないこともあるが厄介なのでここでは考えない)。ポインタはメモリのどこに置かれたのかを示す値を格納する変数だ。その値のことをアドレスという。日本語にすると住所だ。まさしくオブジェクトの居場所を指している的確な用語だ。変数のアドレスを取るには`&`演算子を用いる。書式付き出力関数でポインタの変換指定子は`%p`だ。試しに適当な変数のアドレスを出力してみよう。

```c
#include <stdio.h>

int main(void) {
    int a;
    printf_s("%p\n", &a);
}
```

出力された場所に変数`a`がある。

# ポインタ

ポインタは格納されているアドレスの位置にあるオブジェクトを参照することができる。そのことを参照はがし (*dereference*) といい、ポインタ変数に`*`を付けて記述する。

```c
#include <stdio.h>

int main(void) {
    int a = 1;
    int* p = &a;            // aのアドレスとpに代入

    printf_s("%d\n", *p);   // pが指しているオブジェクトを出力
}
// output
// 1

```

ポインタは関数の引数にして、計算結果を書き込んでもらうことも出来る。その場合関数の戻り値はエラーを報告するために使用することができる。オブジェクトのアドレスを渡すことを参照渡しという。


```c
// sampleディレクトリのoverflow_check.cに同等のプログラムがある。
#include <limits.h>
// a+bを計算して桁あふれを検出する。
// 桁あふれが起こった場合-1を返す。
int add(unsigned int* result_buffer, unsigned int a, unsigned int b) {
    return b <= UINT_MAX - a
        ? *result_buffer = a + b, 0
        : -1;
}
```

また、ポインタはコピーするのが億劫な巨大なオブジェクトを関数に渡すための手段としても用いることができる。組み込み型ではそのような型は見かけないが、構造体のサイズを大きくするのは非常に簡単だ。関数に渡されるオブジェクトは全てコピーして渡されるため、構造体をコピーするより構造体のアドレスをコピーして渡すほうがスタックの消費量や処理にかかる時間を押さえることができる場合が多い。

## constポインタ

ポインタが指すオブジェクトが書き換えられないことを保証したいときはポインタに`const`を付ける。今更だが`const`は何もポインタに対してだけ用いるものではない。他の型に対しても書き換えたくない場合は`const`を指定して読み取り専用の変数のように扱うことができる。

ただしポインタは`const`を付ける位置によって読み取り専用になるものが変わるので注意が必要だ。

```c
int a = 0;
int b = 1;
const int* p1 = &a;         // int const*でもよい
int* const p2 = &a;
const int* const p3 = &a;   // int const * constでもよい
p1 = &b;                    // 合法
p2 = &b;                    // error! p2自体は読み取り専用
p3 = &b;                    // error! p3自体は読み取り専用

*p1 = 2;                    // error! p1が指す先は読み取り専用
*p2 = 2;                    // 合法
*p3 = 2;                    // error! p3が指す先は読み取り専用

p1 = p2;                    // 合法
p1 = p3;                    // 合法
p2 = p1;                    // error!
p2 = p3;                    // error!
p3 = p1;                    // error!
p3 = p2;                    // error!
```

## ヌルポインタ

ポインタにはヌルポインタという無効値を持たせることができる。ヌルポインタとは`0`の値を持つ整数定数式、またはそのような式を`void*`にキャストした式だ。その式はマクロで`NULL`として定義されている。

```c
#define NULL ((void*)0)
// もしくは
#define NULL 0
```

ヌルポインタのような無効なポインタに対して参照はがしすると未定義動作となる。

## ダングリングポインタ

最も厄介なものにダングリングポインタというものがある。その名の通りポインタの指している場所が不正なメモリ領域になってしまい、宙ぶらりんになっているポインタのことだ。では早速不正なポインタを作ろう。その扱いの厄介さと比べて作るのは非常に容易であるため、バグが発生しやすい。C++という言語ではC以上にダングリングポインタを発生させやすくするラムダ式の参照キャプチャ機能があるが、ここではその話をすることはない。

```c
int* f() {
    int a;
    return &a;
}

int main(void) {
    int* dangling_pointer = f();
}
```

[変数の項目](06_variable.md)で話したように、変数には寿命がある。その寿命が尽きた変数があった場所には何があるか分からない。関数`f`の中の変数`a`は`return`文の後その寿命を迎える。`dangling_pointer`にアクセスすることはとてもいけないことだ。

# エイリアシング


