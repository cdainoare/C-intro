# 関数

これまで書いてきたCプログラムにも何度も関数を書いてきた。お遊びの内容を除けば扱ったのは`main`関数のみだが、お察しの通りCでは`main`以外にも自分で勝手に関数を作ることができる。
関数とは入力に対して1つ以下の出力があるようなものだ。

## プロトタイプ宣言

関数プロトタイプとは関数本体を省略して関数のシグネチャを示したものだ。それを宣言することを関数プロトタイプ宣言という。関数プロトタイプ宣言は定義が兼ねることが多いが、相互に呼び出しあう複数の関数が存在する場合関数プロトタイプ宣言をする必要がある。関数プロトタイプ宣言は以下のようになる。

```
戻り値の型名 関数名(引数リスト);
```

戻り値の型名, 関数名, 引数リストというシグネチャのみを的確に示している。例えば

```c
int main(void);
```

このようなプロトタイプ宣言からは関数名が`main`であり、戻り値が`int`型であり、0個の引数を受け取る関数であることが分かる。評価される文でこの関数呼び出しを書きたいならばどこかでこの関数を定義しなければならない。

ちなみに、プロトタイプ宣言はシグネチャさえわかればどんな方法で書いても構わない。例えば、[型の話](03_type.md)をした時に学んだ`typedef`を使ってプロトタイプ宣言を書いてみることも出来る。

```c
typedef int F(void);    // 戻り値の型がintで引数を受け取らない関数の型Fを定義

F main;                 // 戻り値の型がintで引数を受け取らない関数型の識別子mainを宣言
```

なかなか見ない記法だが、これはCの規格書にも載っている正規の方法なので安心して使うことができる。

## 定義

どんなCプログラムでも少なくとも一つは関数定義を含んでいる。察しの良い読者諸君なら気付いているだろう。`main`関数のことだ。

関数定義はプロトタイプ宣言に`{}`を付けるだけだ。今までずっと書いてきた`main`関数ならば特別に`return`文を省略できるので本当に`{}`だけでよい。`main`関数か戻り値が`void`な関数以外の場合、`return`文を省略してはいけない。

```
型名 関数名(引数リスト) {
    // sometask;
}
```

## 引数と戻り値

引数とは関数に外部から渡すことができる値で、戻り値とは関数が呼び出し元に返す値だ。引数は複数受け取ることができるが、戻り値は常に一つ以下だ。戻り値を返すには`return 式;`と書く。先ほどから`int main(void)`ばかりで引数を受け取ったことがなかったので、いい加減引数を受け取って、人間にとって意味のある戻り値を返す関数を書いてみよう。

関数では頻繁に書くような処理を書くと実際のプログラミングで便利だ。今回は3つの値を受け取って平均を返すような関数を書いてみよう (こんなもの実際のプログラミングでは全く使わないが)。

```c
double avg(int a, int b, int c) {
    return (a + b + c) / 3.0;
}
```

引数リストではたとえ同じ型でも`int a, b, c`という風には書くことはできない。いや、書くことができないわけではないが、一般的ではない。どうしてもタイプ量を減らしたい、例えばすべての引数が`unsigned long long int`型で、`typedef`も宗教上の理由で使えない場合は、以下のようにしてタイプ量を減らすことができる。ちなみに、`<stdint.h>`には`unsigned long long int`の別名として`uint64_t`が定義されているのでそちらを使うほうが良い (LLP64の話)。

```c
double avg(a, b, c)
unsigned long long int a, b, c;
{
    return (a + b + c) / 3.0;
}
```

このような記法はすでに推奨されていない。ANSI C標準ができる前の古い書き方だ。

関数を呼び出すには以下のようにする。

```c
関数名(実引数);
```

例えばさっきの`avg`関数を呼び出す場合以下のようになる。

```c

double avg(int a, int b, int c) {
    return (a + b + c) / 3.0;
}

int main(void) {
    avg(3, 4, 5);   // 関数呼び出し
}
```

## 関数ポインタ

Luaのような言語をかじったことがある者ならば、関数を変数に代入したこともあるだろう。あれは関数オブジェクトといい、関数ポインタの進化系だ。Cはもっと原始的な方法で関数を変数に格納する。

Cに限らず大抵の言語はソフトウェアで扱う仮想的なメモリ領域を4つに分けている。変数が格納されるのは[変数の項](06_variable.md)でも話した3つだが、最後の一つにテキスト領域という場所があり、そこには機械語のプログラムが格納されている。関数ポインタとはつまりテキスト領域にある関数のプログラムの場所を指し示した値だ。

関数ポインタの構文は極めて厄介だ。宗教上の理由で`typedef`を使えない人は覚悟して聞いてほしい。

```
戻り値の型名 (*変数名)(引数リスト);
```

これでわかったら読者は経験者だ。試しにさっきの`avg`関数を変数に格納してみよう。

```c
// function_pointer.c
double avg(int a, int b, int c) {
    return (a + b + c) / 3.0;
}

int main(void) {
    double (*function)(int, int, int) = avg;
}
```

まだイマイチよくわかっていないだろう。では`typedef`を使ってもっと変数っぽく書けばわかるはずだ。

```c
typedef double(*func_t)(int, int, int);

double avg(int a, int b, int c) {
    return (a + b + c) / 3.0;
}

int main(void) {
    func_t function = avg;
}
```

いつも見る変数と同じような定義だ。

こんな面倒な関数ポインタの何が便利なのかと思うかもしれないが、例えばWin32APIでGUIアプリケーションを作るとき、ユーザーが操作して発行されたイベントを処理するウィンドウプロシージャというものをプログラマーがカスタムできるようになる (APIが提供するDefWindowProcを置き換えられるようになる)。

関数ポインタに格納された関数を呼び出すには、変数名に`*`をつけて`(*変数名)(実引数)`のようにする。括弧が多いと思うかもしれないが、これは演算子の優先順位が決まっているため仕方のないことだ。

```c
typedef double(*func_t)(int, int, int);

double avg(int a, int b, int c) {
    return (a + b + c) / 3.0;
}

int main(void) {
    func_t function = avg;
    (*function)(3, 4, 5);
}
```
