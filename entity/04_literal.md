# リテラル

リテラルとはソースコード上に直接埋め込まれた定数のことであり、その値を変更することはできない。この先学ぶであろう変数とは対照的だ。Cの定数は以下のような制約を持つ。

>Each  constant  shall  have  a  type  and  the  value  of  a  constant  shall  be  in  the  range  of representable values for its type.

日本語にすれば

>定数は型とその型で表現可能な範囲の値を持っていなければならない。

ということだ。

例えばC言語のソースコード中に単に`0`と書けばそれは`int`型のリテラルとなり、値は0である。また、`"hello world"`と書けばそれは`char`型の値が12個並んだものと解釈される。文字列に関して学ぶのは大分先になるが、C言語では一般に文字列は文字数+1の長さがある。

## 接頭辞、接尾辞

C言語のリテラルでは特殊な記法を用いてリテラルの意味を変えることができる。

### 整数リテラル

整数リテラルでは普通は10進数で値を書く。使える数字は`/[0-9]/`だ。接尾辞も接頭辞も書かなければよほど大きな数字でない限り`signed int`の値になる。例えばソースコード中に`15`と書けば私たちが普段使っている10進数での15という値になる。
整数リテラルでは以下の接頭辞が使える。

- `0`

    後に続く数値を8進数として解釈する。このリテラルに指定できる数字は`/[0-7]/`だ。

- `0x`もしくは`0X`

    後に続く数値を16進数として解釈するこのリテラルに指定できる数字は`/[0-9a-fA-F]/`だ。

例えば`010`と書いたら10進数では8になり、`0xF`は15である。

また整数リテラルには接尾辞も指定できる。

- `u`または`U`

    リテラルを符号なし整数値(`unsigned int`)として解釈する。

- `l`または`L`

    リテラルを`long`として解釈する。但し`14.25L`など小数点を含むものは`long double`型になるので注意すること。

- `ll`または`LL`

    リテラルを`long long`として解釈する。

また、接尾辞を複数組み合わせ`ull`や`ul`などと指定することも出来る。例えば`10u`の型は`unsigned int`であるし、`10ull`の型は`unsigned long long`だ。

接尾辞を付けなくとも、値が型で表現できる値を超えれば、次に大きい型に格上げされる。例えば`0xFFFFFFFFFFFF`などは接尾辞がついていないが、`int`で表現できる値を超えているので、`long`か`long long`になる。

### 浮動小数点リテラル

浮動小数点リテラルは10進数で値を書く。残念ながらC言語ではこれを変えることはできない。浮動小数点に使える数字は`/[.0-9]/`だ。原則として`10.5`のように数字の後に小数点を書き、そのあとにまた数字が続く。但し、小数点以下がすべて0の時は小数点の後の数字を省略できる。`5.`は`5.0`だ。また、絶対値が1未満の場合、小数点より前の数字を省略できる。`.25`は`0.25`だ。

浮動小数点に接頭辞はない。浮動小数点型を8進数や16進数で表現するのは困難を極めるからだ。そもそも浮動小数点型は符号部、指数部、仮数部に分かれており、仮数部の値(正確には仮数部の値の最上位に1を付け加えた値)を指数部で表される値だけ小数点をずらすことで表現されているため、`0x1`と書いて`float`型などにそのままマッピングしても`1`にはならない。

浮動小数点リテラルに接尾辞を指定しない場合は`double`型として解釈される。

浮動小数点型では接尾辞のみが指定できる。以下はその一覧だ。

- `f`または`F`

    リテラルを`float`型として解釈する。

- `l`または`L`

    リテラルを`long double`型として解釈する。但し`14L`など小数点を含まないリテラルは`long`型になるので注意すること

### 文字リテラルと文字列リテラル

聡い読者の皆さんはすでにお察しかと思うが、[型](03_type.md)で示されたように文字には`char`型を使う。すなわち文字は数値だ。それもたった256種類の数値しか表すことができない整数値だ。ただ、256種類では平仮名や漢字を含めた文字を表現できないため、そのような種類の文字を扱う場合は`char`型の値を複数まとめて1文字と解釈する。文字コードの話は本筋とずれてしまうのでここではしないが、気になる読者は`Shift-JIS`や`UTF-8`などについてGoogleで調べると良いかもしれない。

さて、先ほど文字は`char`型で表されるといったが、実はそれだけではない。世の中には1文字が必ず2byte以上になったり、4byteになる文字コードも存在する。C言語ではそういった文字コードにも対応するため、`<stddef.h>`や`<uchar.h>`でUTF-16やUTF-32でエンコードされた文字に使用されるべき型が定義されている。では各文字コードにおけるリテラルを見ていこう。

もっとも一般的な接頭辞がない文字リテラルは`'`(シングルクォーテーション)で囲まれた文字かエスケープシーケンスでなければならない。同じくその文字リテラルに2文字以上記述したり、1バイト文字としてマップされていない文字またはエスケープシーケンスを記述した場合は処理系定義である。


以下は文字リテラルの接頭辞だ。C言語の文字リテラルには接尾辞はない。

- `L`

    `wchar_t`型の文字。

- `u`

    `char16_t`型の文字。この接頭辞が付くリテラルは`__STDC_UTF_16__`の値が`1`ならばUTF-16でエンコードされる。

- `U`

    `char32_t`型の文字。この接頭辞が付くリテラルは`__STDC_UTF_32__`の値が`1`ならばUTF-32でエンコードされる。

- 接頭辞なし

    `char`型の文字。

例えば、`'\0'`は`char`型で`0`という値だ。`'a'`は`0x61`と同じ値だ。

文字列リテラルは文字が並んだ構造のデータだ。文字列リテラルは0文字以上の文字を`"`(ダブルクォーテーション)で囲む。接頭辞も文字リテラルと同じものが使える。また、文字列リテラルだけは文字リテラルの接頭辞に加えてさらに`u8`接頭辞も使うことができる。

- `u8`

    *UTF-8 string literal*と呼ばれ、文字列に含まれるそれぞれの文字は`char`型で、UTF-8でエンコードされた値である。

例えば`"C programming language"`と書けば`unsigned char`型の文字が23個連なっていることになる。

#### エスケープシーケンス

文字と文字列のリテラルにはエスケープシーケンスというものがある。特別な文字や値を表現するための特別な記法だ。リテラル中で`\`(バックスラッシュ)に続けて特定の文字や数値を書けばそれぞれ対応する値になる。

エスケープシーケンスで表現する特別な文字には以下のようなものがある。
|文字|エスケープシーケンス|
|:--|:--|
|single quote `'`|`\'`|
|double quote `"`|`\"`|
|question mark `?`|`\?`|
|backslash `\`|`\\`|
|octal character|`\` *octal digits*|
|hexadecimal character|`\x` *hexadecimal digits*|

尚、8進および16進エスケープシーケンスの値は文字型の範囲に収まっていなければならない。
