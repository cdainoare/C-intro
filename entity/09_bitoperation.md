# ビット演算

コンピュータというのはあらゆるものを2進数で表現している。整数や浮動小数点や文字など、表面的には10進数や文字として見えるものも内部ではビットの連続だ。そしてC言語では整数型に限りビットを直接操作することができる。概念を理解しやすくするためにまずはビットの話からしよう。

## ビット

ビットというのは2つの異なる状態のどちらかを表現できる。具体的には`0`と`1`だ。ビットを8個集めて1バイトになる。

ボールペンを想像しよう。ボールペンは先が出ている状態と、先が出ていない状態の二つの状態のどちらかを表現できる。つまり、ボールペンは1ビットの情報を表現できる。これからやるビット演算はボールペンの先を出したりしまったりするだけで、そんなに難しいことではない。ただしペンの数は多いが。

## 演算子

ビット演算に使う演算子は`|`, `&`, `^`, `~`, `<<`, `>>`だけだ。大学などでブール代数を学んでいると理解し易いが、ブール代数の単位を落としていたり、まだ学んでいなくても全く問題ない。

### ビットごとの論理和

早速だがビット同士の足し算について考えよう。算数では $1+1=2$ になる。 $1+0=1$ で、 $0+1=1$ だ。さすがにこれが分からない読者はいないだろう。

しかし、ビット同士の足し算では $1∨1=1$ で、 $1∨0=0∨1=1$ である。これはそういうものなんだと覚えてもらうしかない。ビットは一桁で2値しか表せないので覚えても負担にはならないだろう。

Cでは`|`演算子で整数型のビットごとに論理和を適用する。例えば`2|1`は`3`と同じだ。`4|2`ならば`6`になる。`10|2`は`10`だ。このようにビットごとの論理和では二つの項のうちどちらかのビットがたっていれば計算結果は1になる。

```
     1010
OR   0010
=    1010
```

```c
unsigned int answer = 10 | 2;
```

### ビットごとの論理積

次はビット同士の掛け算について考えよう。算数では $1 \times 1 = 1$になり、 $1 \times 0 = 0$になる。幸運なことにこれは論理積でも同じだ。 $1∧1=1$ で $1∧0=0∧1=0$ となる。論理積とは二つの項のビットが共に立っていれば1、それ以外では0になる演算だ。

Cでは`&`演算子で整数型のビットごとに論理積を適用する。例えば`15&13`は13で、`2&4`は0になる。

```
     0010
AND  0100
=    0000
```

```c
unsigned int answer = 2 & 4;
```

### ビットごとの排他的論理和

この演算は算数に似た演算がない。読者のほとんどが初めて触れる概念になるだろう。排他的論理和とは左の項が1ならば右の項を反転させたものを結果とする演算だ。右の項が1ならば左の項を反転させると考えてもよい。また、どちらか片方だけが1なら1などと考えるのもよい。ベン図でイメージをつかんでもよいだろう。

この演算はXORとも呼ばれる。

1ビット同士の演算だと以下のようになる。

```
1 XOR 1 = 0
1 XOR 0 = 1
0 XOR 1 = 1
0 XOR 0 = 0
```

ではこれをCの整数型でやってみる。Cではビットごとのこの演算に`^`演算子を用いる。では、10と10のXORを計算してみる。

```
     1010
XOR  1010
=    0000
```

`10 XOR 10 = 0`だ。ある数と同じ数をXOR演算すると必ず0になる。

次に10と6のXORを計算してみる。

```
     1010
XOR  0110
=    1100
```

`10 XOR 6 = 12`になった。12にもう一度6をXOR演算してみる。

```
     1100
XOR  0110
=    1010
```

```c
unsigned int answer = 12 ^ 6;
```

`12 XOR 6 = 10`と最初の数に戻った。ある数pとqがあるとき、`(p XOR q) XOR q = p`となる。XOR演算はこのように便利な性質をいくつか持っている。

### ビットごとの否定

これまでの演算が2項必要だったのに対してこの演算は単項演算だ。あるビットにこの演算を行うとそのビットとは逆の値が得られる。この演算はNOTともいう。例えば1に対して`NOT 1 = 0`になり、`NOT 0 = 1`になる。

C言語ではこれをビットごとに行う。負の数の表現が2の補数表現である環境で、符号付整数型の変数`p`に0が格納されている状態でビットごとにNOT演算を行うと`-1`になる。2進数で表現すると演算は以下のようになる。なお簡単のため4ビットのみ計算する。

```
NOT 0000 = 1111
```

この演算はただビットをひっくり返すだけだ。Cではこの演算に`~`演算子を用いる。

```c
unsigned int answer = ~0;
```

### 左シフト

左シフトはビットを左にシフトする演算だ。エンディアンについて知っている場合は今はそのことについて考える必要はない。0xFEがメモリやCPU上で0xEFと表現される環境でも0xFEと表現される環境でもシフト演算はプログラマーが思っている通りの挙動をする。

左シフト演算は2項演算だ。Cでは左シフト演算に`<<`演算子を用いる。`1 << 1`は2になり、`1 << 2`は4になる。

二進数で表現すると以下の通りだ。

```
0001 << 1 == 0010
0001 << 2 == 0100
```

```c
unsigned int answer = 1 << 2;
```

### 右シフト

右シフトはビットを右にシフトする演算だ。Cでは右シフト演算には`>>`演算子を用いる。

右シフト演算には論理シフトと算術シフトがある。これはシフトする整数型が何であるかによって変わる。論理シフトは符号なし整数(unsignedがつく)型に適用される。例えば`unsigned char`型に対しての論理シフトは以下のようになる。

```
1000 0100 >> 2 = 0010 0001
```

特段注意すべき点はない。そのままシフトして空いたビットは0を埋め、はみ出したビットは捨てる。

では算術シフトを見てみよう。`signed char`型の二つの数値に対して右シフトを適用してみる。`-128`と`1`を2ビット右にシフトする。

```
1000 0000 >> 2 = 1110 0000
0000 0001 >> 2 = 0000 0000
```

はみ出したビットを捨てるというところは同じだが、-128を右シフトしたとき1が増えてしまった。これが算術シフトの注意すべき点だ。**`singed`な型に対して右シフトを行うと空いたビットには元の符号ビットが埋められる**。
