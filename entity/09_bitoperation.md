# ビット演算

コンピュータというのはあらゆるものを2進数で表現している。整数や浮動小数点や文字など、表面的には10進数や文字として見えるものも内部ではビットの連続だ。そしてC言語では整数型に限りビットを直接操作することができる。概念を理解しやすくするためにまずはビットの話からしよう。

## ビット

ビットというのは2つの異なる状態のどちらかを表現できる。具体的には`0`と`1`だ。ビットを8個集めて1バイトになる。

ボールペンを想像しよう。ボールペンは先が出ている状態と、先が出ていない状態の二つの状態のどちらかを表現できる。つまり、ボールペンは1ビットの情報を表現できる。これからやるビット演算はボールペンの先を出したりしまったりするだけで、そんなに難しいことではない。ただしペンの数は多いが。

## 演算子

ビット演算に使う演算子は`|`, `&`, `^`, `<<`, `>>`だけだ。大学などでブール代数を学んでいると理解し易いが、ブール代数の単位を落としていたり、まだ学んでいなくても全く問題ない。

### 論理和

早速だがビット同士の足し算について考えよう。算数では $1+1$ は2になる。 $1+0=1$ で、 $0+1=1$ だ。さすがにこれが分からない読者はいないだろう。

しかし、ビット同士の足し算では $1∨1=1$ で、 $1∨0=0∨1=1$ である。これはそういうものなんだと覚えてもらうしかない。ビットは一桁で2値しか表せないので覚えても負担にはならないだろう。

Cでは`|`演算子で整数型のビットごとに論理和を適用する。例えば`2|1`は`3`と同じだ。`4|2`ならば`6`になる。`10|2`は`10`だ。このようにビットごとの論理和では二つの項のうちどちらかのビットがたっていれば計算結果は1になる。

```
     1010
OR   0010
=    1010
```

### 論理積

次はビット同士の掛け算について考えよう。算数では $1 \times 1 = 1$になり、 $1 \times 0 = 0$になる。幸運なことにこれは論理積でも同じだ。 $1∧1=1$ で $1∧0=0∧1=0$ となる。論理積とは二つの項のビットが共に立っていれば1、それ以外では0になる演算だ。

Cでは`&`演算子で整数型のビットごとに論理積を適用する。例えば`15&13`は13で、`2&4`は0になる。

```
     0010
AND  0100
=    0000
```

### 排他的論理和

この演算は算数に似た演算がない。読者のほとんどが初めて触れる概念になるだろう。排他的論理和とは左の項が1ならば右の項を反転させたものを結果とする演算だ。右の項が1ならば左の項を反転させると考えてもよい。また、どちらか片方だけが1なら1などと考えるのもよい。ベン図でイメージをつかんでもよいだろう。

この演算はXORとも呼ばれる。

1ビット同士の演算だと以下のようになる。

```
1 XOR 1 = 0
1 XOR 0 = 1
0 XOR 1 = 1
0 XOR 0 = 0
```

ではこれをCの整数型でやってみる。Cではビットごとのこの演算に`^`演算子を用いる。では、10と10のXORを計算してみる。

```
     1010
XOR  1010
=    0000
```

`10 XOR 10 = 0`だ。ある数と同じ数をXOR演算すると必ず0になる。

次に10と6のXORを計算してみる。

```
     1010
XOR  0110
=    1100
```

`10 XOR 6 = 12`になった。12にもう一度6をXOR演算してみる。

```
     1100
XOR  0110
=    1010
```

`12 XOR 6 = 10`と最初の数に戻った。ある数pとqがあるとき、`(p XOR q) XOR q = p`となる。XOR演算はこのように便利な性質をいくつか持っている。
