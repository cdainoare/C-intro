# 論理演算

選択文の解説に入る前に論理演算について確認しておく。

Cではある値が0でなければ真、0であれば偽となる。論理演算とは真と偽について行う演算だ。ビット演算と同じような演算がいくつもあるが、どれもビット演算より簡単だ。
先に[ビット演算](09_bitoperation.md)について読んでおくと理解が早いはずだ。

論理演算ではビット演算と同じように論理和(`||`)、論理積(`&&`)、否定(`!`)の演算が存在するが、排他的論理和を単体で表す論理演算子は存在しない。演算の結果は`int`型を持つ。

## 論理和

この演算はビットごとには行われない。ある数p, qの少なくともどちらかが真の場合`p || q`は真になる。

## 論理積

この演算はビットごとには行われない。ある数p, qの両方が真の場合`p && q`は真になる。

## 否定

この演算はビットごとには行われない。ある数pについてpが真の場合`!p`は偽になり、pが偽の場合`!p`は真になる。

## 排他的論理和

ビットごとではない排他的論理和を単体で表す論理演算子は存在しないが、複数の演算子を組み合わせて比較的簡単に排他的論理和を演算できる。ある数p, qの排他的論理和は以下のように書くことができる。

```c
(!!p) ^ (!!q)
(p || q) && !(p && q)
```

# 関係演算、等価演算

## 関係演算子

関係演算子は4つある。`<`(小さい)、`>`(大きい)、`<=`(以下)、`>=`(以上)だ。各演算子は指定された関係が真の場合は1を、偽の場合は0を返す。その結果は`int`型を持つ。

余談だが、`<`演算子さえ存在していればほかの演算は`<`演算子を用いて記述することができる。例えば、任意の値aとbについて、`a < b`という式がwell-formedであるとしよう。

この時`>`演算子と同じ結果を返す式は`b < a`だ。

`<=`と`>=`は難しいので分けて考えよう。まず`a <= b`が成り立つ場合`a`は`b`より小さいか等しい。`<`演算子はすでにあるので、等しいか比較する演算が必要だ。`a`と`b`が等しい場合、`a`は`b`より小さくないし、大きくもない。つまり、先ほど導いた`b < a`という式を使うことができる。論理の否定には`!`演算子を用いるので、`a`と`b`が等しいかどうかは`!(a < b) && !(b < a)`という式で得られる。よって`a <= b`は`(a < b) || (!(a < b) && !(b < a))`と表すことができる。

同様に`a >= b`は`(b < a) || (!(a < b) && !(b < a))`となる。

## 等価演算子

余談で語った等しいかどうか判定する演算子は実はCには組み込みで用意されている。`==`(等しい)、`!=`(等しくない)を表す各演算子はその関係が真の時に1を、偽の時に0を返す。

----

例

```c
// relationaloperator.c
#include <assert.h>
#include <stdio.h>
int main(void){
    int a, b;
    scanf_s("%d %d", &a, &b);
    assert(a < b == a < b);
    assert(a > b == b < a);
    assert(a <= b == ((a < b) || (!(a < b) && !(b < a))));
    assert(a >= b == ((b < a) || (!(a < b) && !(b < a))));
}
```

# 選択文

選択文とは制御式の値に応じていくつかの文の中から一つを選択するための構文である。

## if文

```
if (式) 文
if (式) 文 else 文
```

`if`文の制御式は、スカラ型をもたなければならない。式の値が0と比較して等しくない場合、最初の副文を実行する。`else`が後に続く場合、直前の`if`の式の値が0と等しい場合、2番目の副文を実行する。`else`は、その`else`の前で最も近い位置にある`if`と結びつく。

例

```c
int a;
scanf("%d", &a);
if(!a) {
    puts("a is 0");
} else {
    if(a == 1){
        puts("a is 1");
    } else puts("a is not 0");
}
```

余談だが、選択文はブロックであるため、副文が一つの文しか含まない場合波括弧`{}`を省略できる。すると先のコードは以下のように書きかえることができる。

```c
int a;
scanf("%d", &a);
if(!a) puts("a is 0");
else
    if(a == 1) puts("a is 1");
    else puts("a is not 0");    // このelseは1行上のifと結びついている。
```

実際には`else if`という構文は無いが、インデントを調整すればあたかもRubyなどのelifと同じように記述することができる。

```c
int a;
scanf("%d", &a);
if(!a) puts("a is 0");
else if(a == 1) puts("a is 1");
else puts("a is not 0");    // このelseは1行上のifと結びついている。
```

## switch文

```
switch(制御式) 文
```

switch文の制御式は整数型を持たなければならない。switch文は制御式の値、*switch body*と呼ばれる文の中の`default`ラベルの有無及び`case`ラベルの値に応じて*switch body*, *switch body*の中の文または*switch body*の次の文に制御を移す。*switch body*の途中で*switch body*の次の文へ制御を移す場合は`break`文を用いる。`break`を用いない場合次のラベルに到達したとしても制御は*switch body*からは抜けない。

```c
int a;
scanf_s("%d", &a);
switch(a){
case 1:     // aの値が1の場合
    puts("a is 1");
    break;  // switch文を抜ける。

case 2:     // aの値が2の場合
            // default文へ抜ける。

default:    // aの値がいずれのcase定数式とも一致しない場合。
    puts("a is not 1");
}
```

## オマケ:条件演算子

```
論理若しくは式 ? 式 : 式
```

条件演算子は演算子であって、選択文ではない。しかし`if`や`switch`と同じく数少ない条件分岐のための要素に他ならないのでこの項で説明する。条件演算子は3つのオペランドをとる。Excelの`IF`関数のように、第一オペランドが真の場合、第二オペランドを評価しその結果を返す。第一オペランドが偽の場合第三オペランドを評価しその結果を返す。

第二および第三オペランドの型には制約がある。

- 両オペランドの型が算術型である。
- 両オペランドの型が同じ構造体型又は共用体型である。
- 両オペランドの型が void 型である。
- 両オペランドが適合する型の修飾版又は非修飾版へのポインタである。
- 一方のオペランドがポインタであり，かつ他方が空ポインタ定数である。
- 一方のオペランドがオブジェクト型又は不完全型へのポインタであり，かつ他方が void の修飾版又は非修飾版へのポインタである。

これらの条件は大変覚えるのがしんどい。第二オペランドと第三オペランドが同じ型であれば間違いはないので、両オペランドの型をそろえるようにしよう。

```c
void f() { /*...*/ } 
int g() { /*...*/ }

_Bool cond = /*....*/;

cond ? f() : g();       // error! 第二および第三オペランドの条件を満たしていない!
cond ? f() : (void)g(); // 問題なし
```
