# 任意の数のオブジェクトを扱おう

突然だが、最大5個の整数を読み込んで平均とそれぞれの要素との差を求めてみよう。入力は整数の個数とそれぞれの整数に分けられる。

以下は入力のフォーマットだ。Nは最大で5とする。

```
N
V_0 V_1 V_2 ...V_N-1
```

```c
#include <stdio.h>

int main(void) {
    int v0, v1, v2, v3, v4;
    int N;
    int sum = 0;
    double avg;
    scanf_s("%d", &n);
    if(N>0) {scanf_s("%d", &v0); sum += v0}
    if(N>1) {scanf_s("%d", &v1); sum += v1}
    if(N>2) {scanf_s("%d", &v2); sum += v2}
    if(N>3) {scanf_s("%d", &v3); sum += v3}
    if(N>4) {scanf_s("%d", &v4); sum += v4}

    avg = sum / (double)N;
    if(N>0) printf_s("avg:%f\navg-v0:%f", avg, avg - v0);
    if(N>1) printf_s("avg:%f\navg-v1:%f", avg, avg - v1);
    if(N>2) printf_s("avg:%f\navg-v2:%f", avg, avg - v2);
    if(N>3) printf_s("avg:%f\navg-v3:%f", avg, avg - v3);
    if(N>4) printf_s("avg:%f\navg-v4:%f", avg, avg - v4);
}
```

非常に面倒だ。`v0`から`v4`まで同じ型でメモリ上でも連続しているのだから、もっと楽に扱う方法がある。それが配列だ。

# 固定長配列

固定長配列は同じ型の複数の変数をまとめて扱うための機能だ。配列の機能はC言語のコア機能として組み込まれている。配列は以下のように定義する。

```
型名 変数名[サイズ];
```

例えば、`int`型で要素数が10個の固定長配列は`int a[10];`と定義される。この時、固定長配列の要素数はコンパイル時定数でなければならない。例えば`scanf_s`で読み込んだ値を要素数にすることはできない (C99ではそのような配列の定義も有効だったが、C11ではその機能のサポートは任意となっている)。

定義した固定長配列を初期化するには`{}` (波括弧) を使う。

```c
int a0[3] = {};         // 全ての要素が0で初期化される
int a1[3] = {1, 2, 3};  // a1の要素は最初から順に1, 2, 3
int a2[]  = {1, 2, 3};  // a2の要素数は初期化式に応じて自動的に3に決まる
int a3[4] = {1, 2, 3};  // a3の明示的に初期化されない要素は0で初期化される
int a4[4];              // 要素の初期値は未定義
```

固定長配列の要素にアクセスするには`[]` (添え字演算子) を使う。また、固定長配列の要素数をNとしたとき、添え字は0~N-1の値を取らなければならない。`int a[3]`のような固定長配列に`a[3]`とすれば未定義動作となる。

```c
#include <stdio.h>
int main(void) {
    int a[10];
    // 配列の入力
    for(int i = 0; i < 10; ++i) {
        scanf_s("%d", &a[i])    // aのi番目の要素のアドレス
    }
    // 配列の出力
    for(int i = 0; i < 10; ++i) {
        printf_s("%d ", a[i]);  // aのi番目の要素の値
    }
}
```

## 配列とポインタ

配列は式中ではポインタとして扱うことができる。単に配列名を式中に書いた場合、それは配列の先頭要素へのポインタになる。そしてポインタと整数型は加算と減算できる。ポインタ型に1を足すと、そのポインタが指していた次のメモリ位置にあるオブジェクトを指すようになる。例外的に`sizeof`と`&`演算子のオペランドであるときだけ固定長配列の実体を指しているような挙動をする。面白いことに、その機能を使って固定長配列をちょうど一周するようなループを簡単に書くことができる。以下のようなループを書けば固定長配列の要素数がいくつになろうとループを書き換える必要は無くなる。

```c
#include <stdio.h>

int main(void) {
    int a[10] = { /* initialization */ };
    // 配列aの大きさを配列aの一つの要素の大きさで割る = 配列の要素数
    for(size_t i = 0; i < sizeof a / sizeof *a; ++i) {
        printf_s("%d ", a[i]);
    }
}

```

配列を式中に書いた場合、先頭要素へのポインタになってしまうということは、配列の中身が等しいかあるいは大きいかを配列名同士の`==`演算子で比較することはできないということだ。

```c
int a[3] = {1, 2, 3};
int b[3] = {1, 2, 3};
a == b;     // ポインタ同士の比較になる。常にfalse。
```

配列を要素の値で比較するためには要素を一つ一つ比較する以外に手はない。

```c
#include <stdbool.h>
bool is_equal_array(const void* a, const void* b, size_t size) {
    const unsigned char* right = (const unsigned char*)a;
    const unsigned char* left = (const unsigned char*)b;
    for(size_t i = 0; i < size; ++i) {
        if(right[i] != left[i]) return false;
    }
    return true;
}
```

### []演算子はシンタックスシュガー

ところで、`[]` (添え字演算子) というのはシンタックスシュガーだ。シンタックスシュガーというのは既存の構文を別の構文や記法で記述できるようにしたものだ。では、`[]`を使わない固定長配列要素へのアクセスの方法を見ていこう。`a[b]`とは`(*((a) + (b)))`と全く同じ意味だ。`[]`演算子はポインタに整数を加算しているだけである。そのため、`b[a]`と書いても正しく動く。

しかしポインタに整数を加算しているだけであるため、配列の境界チェックなどは行われない。要素数が10個の配列にたいして`a[10]`などと書こうものなら未定義動作だ。

```c
#include <stdio.h>
int main(void) {
    int a[10];
    // 配列の入力
    for(int i = 0; i < 10; ++i) {
        scanf_s("%d", a + i)
    }
    // 配列の出力
    for(int i = 0; i < 10; ++i) {
        printf_s("%d ", *(a + i));
    }
}
```

## 言語組み込みの固定長配列は第一級オブジェクトではない

さて、先ほど学んだ配列は、第一級オブジェクトではない。第一級オブジェクトとは、以下の性質を持つ。

- 無名のリテラルとして表現可能
- 変数に格納可能
- データ構造に格納可能
- 他の物との等値性の比較が可能
- 関数の戻り値や引数として返したり渡したりできる
- etc...

Cの配列はこれらの要件を満たしていない。例えば配列は関数の戻り値や引数にすることはできない。以下のような関数はコンパイルエラーだ。

```c
void f(int a[10]);  // error!
```

しかし配列が関数の実行に必要な時もあろうかと思う。Cでは配列をポインタを介して関数とやりとりする。関数の引数に配列を渡すには以下のようにする。

```c
void f(int a[], size_t array_size);
```

配列は関数などにポインタとして渡された時点で配列ではなくポインタとなるため、`sizeof`などで要素数を知ることはできない。そのため配列を関数に渡すときには必ず配列の要素数も一緒に渡す必要がある。

とは言え、固定長配列なのだから関数に渡しても要素数が変わることはないことは確かだ。Cでは配列そのものを配列そのものへのポインタを介して関数などに渡すことができる。

```c
typedef int (*array_ptr)[N];

void f(array_ptr a) {
    // access element of array
    (*a)[0];
    // calc element count of array
    sizeof *a / sizeof **a;
}
```

`array_ptr a`は配列の先頭要素へのポインタではなく、配列へのポインタだ。`*` (間接参照演算子) によって配列にアクセスすることができる。

## 多次元配列

配列の各要素はメモリ上に連続して線形に並ぶ。線形―つまり1次元だ。さっきまでやっていた配列は1次元の配列だった。csvファイルを読み込んだり、マインスイーパーを作るとき配列が1次元だととてもやりにくい。Cでは配列を多次元にできる。コンパイラが許す限り配列の次元は大きくできる。

多次元配列の定義は以下のようにする。

```
型名 配列名[最初の次元の要素数][次の次元の要素数]...[最後の次元の要素数];
```

例えば`int`型で2x2の配列を作りたければ以下のようになる。

```c
int array_2d[2][2] = { {1, 2}, {3, 4} };
```
