# 任意の数のオブジェクトを扱おう

突然だが、最大5個の整数を読み込んで平均と最初の要素の差を求めてみよう。入力は整数の個数とそれぞれの整数に分けられる。

以下は入力のフォーマットだ。Nは最大で5とする。

```
N
V_0 V_1 V_2 ...V_N-1
```

```c
#include <stdio.h>

int main(void) {
    int v0, v1, v2, v3, v4;
    int N;
    int sum = 0;
    double avg;
    scanf_s("%d", &n);
    if(N>0) {scanf_s("%d", &v0); sum += v0}
    if(N>1) {scanf_s("%d", &v1); sum += v1}
    if(N>2) {scanf_s("%d", &v2); sum += v2}
    if(N>3) {scanf_s("%d", &v3); sum += v3}
    if(N>4) {scanf_s("%d", &v4); sum += v4}

    avg = sum / (double)N;
    printf_s("avg:%f\navg-v0:%f", avg, avg - v0);
}
```

非常に面倒だ。`v0`から`v4`まで同じ型でメモリ上でも連続しているのだから、もっと楽に扱う方法がある。それが配列だ。

# 固定長配列

固定長配列は同じ型の複数の変数をまとめて扱うための機能だ。以下のように定義する。

```
型名 変数名[サイズ];
```

例えば、`int`型で要素数が10個の固定長配列は`int a[10];`と定義される。この時、固定長配列の要素数はコンパイル時定数でなければならない。例えば`scanf_s`で読み込んだ値を要素数にすることはできない (C99ではそのような配列の定義も有効だったが、C11ではその機能のサポートは任意となっている)。

定義した固定長配列を初期化するには`{}` (波括弧) を使う。

```c
int a0[3] = {};         // 全ての要素が0で初期化される
int a1[3] = {1, 2, 3};  // a1の要素は最初から順に1, 2, 3
int a2[]  = {1, 2, 3};  // a2の要素数は初期化式に応じて自動的に3に決まる
int a3[4] = {1, 2, 3};  // a3の明示的に初期化されない要素は0で初期化される
int a4[4];              // 要素の初期値は未定義
```

固定長配列の要素にアクセスするには`[]` (添え字演算子) を使う。また、固定長配列の要素数をNとしたとき、添え字は0~N-1の値を取らなければならない。`int a[3]`のような固定長配列に`a[3]`とすれば未定義動作となる。

```c
#include <stdio.h>
int main(void) {
    int a[10];
    // 配列の入力
    for(int i = 0; i < 10; ++i) {
        scanf_s("%d", &a[i])
    }
    // 配列の出力
    for(int i = 0; i < 10; ++i) {
        printf_s("%d ", a[i]);      // iは0~9
    }
}
```

ところで、`[]` (添え字演算子) というのはシンタックスシュガーだ。シンタックスシュガーというのは既存の構文を別の構文や記法で記述できるようにしたものだ。では、`[]`を使わない固定長配列要素へのアクセスの方法を見ていこう。

```c
#include <stdio.h>
int main(void) {
    int a[10];
    // 配列の入力
    for(int i = 0; i < 10; ++i) {
        scanf_s("%d", a + i)
    }
    // 配列の出力
    for(int i = 0; i < 10; ++i) {
        printf_s("%d ", *(a + i));
    }
}
```

固定長配列は式中ではポインタとして扱うことができる。単に配列名を式中に書いた場合、それは配列の先頭要素のアドレスと同じ値を持つ。そしてポインタと整数型は加算と減算できる。ポインタ型に1を足すと、そのポインタが指していた次のメモリ位置にあるオブジェクトを指すようになる。例外的に`sizeof`と`&`演算子のオペランドであるときだけ固定長配列の実体を指しているような挙動をする。面白いことに、その機能を使って固定長配列をちょうど一周するようなループを簡単に書くことができる。以下のようなループを書けば固定長配列の要素数がいくつになろうとループを書き換える必要は無くなる。

```c
#include <stdio.h>

int main(void) {
    int a[10] = { /* initialization */ };
    // 配列aの大きさを配列aの一つの要素の大きさで割る = 配列の要素数
    for(size_t i = 0; i < sizeof a / sizeof *a; ++i) {
        printf_s("%d ", a[i]);
    }
}

```

## 多次元配列

配列の各要素はメモリ上に連続して線形に並ぶ。線形―つまり1次元だ。さっきまでやっていた配列は1次元の配列だった。csvファイルを読み込んだり、マインスイーパーを作るとき配列が1次元だととてもやりにくい。Cでは配列を多次元にできる。コンパイラが許す限り配列の次元は大きくできる。

多次元配列の定義は以下のようにする。

```
型名 配列名[最初の次元の要素数][次の次元の要素数]...[最後の次元の要素数];
```

例えば`int`型で2x2の配列を作りたければ以下のようになる。

```c
int array_2d[2][2] = { {1, 2}, {3, 4} };
```
