# 変数

変数とは値を保存しておくための機能だ。メモリの一部の領域を割いて変数に割り当てる。Cは静的型付け言語であるため、コンパイル時に変数の型が決まる。そのため、コンパイラがその変数がどの型なのかはっきりと判別できるような文法が必要になる。
実は今までに書いてきたコードにも変数というのはちょくちょく登場していた。前回の演算の項では以下のようなコードだった。

```c
int a = 1;
int b;
int c = 4;
a = b = c;
```

変数を定義するには`型名 変数名 (=初期化式);`のように書く。初期化式はなくてもいい。ただし、初期化式を省いた変数定義ではその変数にどんな値が格納されているか未定義であるため、最初の代入をするより前に変数の内容を読んではいけない。以下のコードは未定義の動作を引き起こす。

```c
int main(){
    int a;
    int b = a + 1;  // 未定義!!
}
```

## 名前

変数には名前を付けなくてはいけない。Cでプログラマがオブジェクトに名前を付けるときは以下の条件を満たしている必要がある

- [a-zA-Z]で始まる。
- アンダースコアの連続を含まない。
- 予約語ではない。

変数に付けることができる名前として以下のようなものがある。

`i`, `var`, `buf`, `tmp`, `my_object`, `myObject`, `member_`, `object2`

変数に付けることができない名前として以下のようなものがある。

`int`, `for`, `_object`, `my__object`, `2nd_object`

## 変数の寿命

### ローカル変数

変数にも寿命がある。変数が生まれるのは変数が定義された時だが、では寿命が尽きるのはいつだろうか。

```c
int main(){
    int a;
    // aの寿命はいつ尽きる？
}

```

ほとんどの読者のお察しの通り`a`の寿命は`main`関数の`}`で尽きる。プログラムの実行が`}`より先に進んでしまえばどうやっても`a`にはアクセスできない。

```c
int main(){
    {
        int a;
    }
}
```

このようなコードでは最初の`}`で`a`の寿命が途絶える。このように関数やブロックのスコープで宣言された変数はスコープを外れたときにその寿命を迎える。変数のスコープを局限すれば他のスコープからは見えないため予期しない誤動作を避けることができる反面、ローカル変数の寿命がスコープ内だけであることがのちのちバグを産むことがあるので詳しくは[ポインタ](17_pointer.md)の項を参照してほしい。

たいていのローカル変数はスコープを外れたら寿命が尽きるが、実はスコープを外れても寿命が尽きないローカル変数をつくることができる。それが静的変数だ。静的変数はそうでない変数とは全くことなるメモリ領域に配置される。詳しくは[後述](#記憶領域)するが配置されるメモリ領域が全く異なるために、静的変数はプログラムが始まってから終わるまでの寿命がある。

静的変数はソースコード上で以下のように定義される

```
static 型名 変数名;
```

`static`はCの予約語で静的記憶クラス指定子という。ローカル変数の定義に`static`を付けると寿命が延びる。また初期化式を省略した場合、静的変数は定義時に0で初期化されることが保証されている。先ほど未定義動作を引き起こすとして紹介したプログラムも以下のようにすれば安全だ。

```c
int main(){
    static int a;   // aの中身は0
    int b = a + 1;
}
```

### グローバル変数

Cはローカルにしか変数を作れないというわけではない。見ることは少ないし、見ない方がいいが、Cはグローバル変数というものを定義できる。グローバル変数はプログラムのどこからでも見ることができるし、書き換えることもできる。どこでどんな値が入るかプログラマーが追いきれなくなってバグの原因になる罪深い変数だ。できるだけ使いたくない。

グローバル変数は必ず静的記憶領域に配置される。グローバル変数の宣言と定義は以下のように書く。但し定義をブロックスコープ内に書くとローカル変数になるため、定義も宣言も関数の外に書く。

```c
extern 型名 変数名; // 宣言
型名 変数名;        // 定義
```

おっと、いきなり「宣言」だなんて単語が出てきたぞ。今まで「定義」だけだったのに。Cでは定義されていない変数は実体がなく使用できない。今までのローカル変数はスコープが狭いので定義と宣言を兼ねて書くだけでも問題は起きなかった。ただグローバルでは話は別だ。

普通、プログラムのソースコードは複数ファイルにまたがる。宣言ばかりを集めた`ヘッダファイル`と定義などを含む`ソースファイル`だ。例えば`global_variable.h`でグローバル変数を「定義」しているとしよう。

```c
// global_variable.h
int global_variable;    // 定義
```

そして二つのソースファイル`global_variable1.c`と`global_variable2.c`が存在して、どちらも`global_variable.h`を`#include`している。詳しくはプリプロセッサの項で解説するが、`#include`はその位置に指定されたファイルを挿入するプリプロセッサだ。

```c
// global_variable1.c

#include "global_variable.h"

```

```c
// global_variable2.c

#include "global_variable.h"

int main(){}

```

さあ早速コンパイルしてみよう。リンカからエラーが吐かれたのではないだろうか。筆者の環境では以下のようなエラーが出た。

```
>clang global_variable1.c global_variable2.c
global_variable2-3ef577.o : error LNK2005: global_variable は既に global_variable1-6b452c.o で定義されています。
a.exe : fatal error LNK1169: 1 つ以上の複数回定義されているシンボルが見つかりました。
clang.exe: error: linker command failed with exit code 1169 (use -v to see invocation)
```

つまり`global_variable`が2回以上定義されているからリンクエラーになる。Cでは**単一定義規則** (ODR; one definition rule) というルールを満たさねばならない。そのため複数回定義されるようなシンボルは**ill-formed**だ。

いや待て、`global_variable`は`global_varible.h`で一回しか定義していない！と思っただろうか。確かに私たちがソースコードに`int global_variable`と書いたのは1回きりだがそのあとに二つのソースファイルから`#include`している。そのプリプロセッサが処理された時ソースファイルは以下のようになる。

```c
// global_variable1.c

// global_variable.h
int global_variable;    // 定義

```

```c
// global_variable2.c

// global_variable.h
int global_variable;    // 定義

int main(){}

```

おわかりいただけただろうか。コンパイラから見れば`global_variable`の定義は二つあるのだ。このような問題を回避するために`extern`はある。

定義は一つでなくてはならないが、宣言は同一ならばいくつあってもよい。そのため、それぞれのファイルを以下のように書きかえればコンパイルは通り、想定通りの動作をする。


```c
// global_variable.h
extern int global_variable;    // 宣言

```

```c
// global_variable1.c

#include "global_variable.h"
int global_variable;            // 定義

```

```c
// global_variable2.c

#include "global_variable.h"

int main(){}

```

### ファイルスコープの変数

変数にはその翻訳単位からしか見えない変数というものもある。グローバルスコープでそのまま変数を定義すればグローバル変数だが、`static`を付けて定義すればファイルスコープとなる。

```c
// filescope1.c
static int variable;
```

```c
// filescope2.c
static int variable;

int main(){}
```

先ほどのグローバル変数では定義を2つ書けばエラーが出ていたが、ファイルスコープの変数というのはそのファイルごとに異なる変数である。filescope1.cの`variable`とfilescope2.cの`variable`は別物になる。

## 記憶領域

変数が配置される記憶領域にはソフト的には3つの種類がある。

- 静的記憶領域
- スタック領域
- ヒープ領域

の3つだ。静的記憶領域はグローバル変数や静的変数が配置される領域だ。
スタック領域というのは静的でないローカル変数や、レジスタの退避、リターンアドレスなどが配置される。スタック領域は名前の通りFILOな構造だ。ヒープ領域は動的メモリが配置される。

ローカル変数などスタックに確保されたメモリはスコープを抜けるとスタックのトップが動き、その変数があったメモリは他の目的のために使用できるようになる。試しに実験をしてみよう。

```c
// memory_experiment.c

#include <assert.h>
#include <stdio.h>

void scope_a(int** ptr){
    int a;
    *ptr = &a;
}
void scope_b(int** ptr){
    int b;
    *ptr = &b;
}

int main(){
    int* ptr_a;
    int* ptr_b;
    scope_a(&ptr_a);
    scope_b(&ptr_b);
    printf("%p %p", ptr_a, ptr_b);
    assert(ptr_a == ptr_b);
}

```

Clangでは`ptr_a`と`ptr_b`が同じ値になってくれたが、読者の環境ではどうだろうか。このことは`int a`と`int b`がスタック上の同じ位置に存在していたということである。もちろん「同時に」ではないが。

以下に領域ごとのメモリの使い方をまとめた。

|メモリアドレス|種別|伸びる方向|
|:-:|:-:|:-:|
|high|スタック領域|下|
||ヒープ領域|上|
|low|静的領域|伸びない|
